%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

\documentclass{article}

\usepackage{fullpage}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage[table]{xcolor}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{parskip}
\usepackage{abstract}
\usepackage{url}
\usepackage{float}
\usepackage{enumitem}
\usepackage{fancybox}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[bottom]{footmisc}
\usepackage{hyperref}
\usepackage{makecell}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}


% constants
\newcommand{\COURSE}{02257 Applied Functional Programming}
\newcommand{\TITLE}{Project 3}
\newcommand{\DATE}{January 20, 2015}


\input{macros}


\pagestyle{fancy}
\fancyhf{}
\setlength{\parindent}{0pt}
\setlength{\headheight}{15pt}
\setlength{\headsep}{25pt}
\lhead{\COURSE}
\chead{\TITLE}
\rhead{\DATE}
\cfoot{Page \thepage{} of~\pageref{LastPage}}


\title{\TITLE\\ {\large \COURSE}}
\date{\DATE}
\author{
  Markus Færevaag {\tt s123692}\\
  Simon Altschuler {\tt s123563}
}


\begin{document}
\maketitle
\vspace{10cm}
\doublesignature{Markus Færevaag}{Simon Altschuler} \\
\clearpage

\section{Introduction}
In this report we will describe our experience with implementing the game Nim in F\# using asynchronuos computations.

A note on Nim rules; there are two variations of the game namely mis\`ere and normal play. We have implemented normal play meaning that the winner is the one who takes the last match.

\section{Status}
The game implements all required as well as optional features. The \texttt{Nim.Driver} modules, which manages the flow of application control, utilizes F\#'s \texttt{async} capabilities along with Don Syme's \texttt{AsyncEventQueue}.

The game can fetch games from URLs in the given format, namely a sorted list of heap sizes separated by space.

It is possible to play against the computer, which will punish even the slightest inaccurate move with certain victory. It does this by following a set of fairly simple rules.

We have designed the program in a modular way have achieved a good separation of concerns. To demonstrate that, we have implemented two different user interfaces; a GUI and a CLI. The compiled executable can be run with the command line argument \texttt{-nw} to use the CLI.

The GUI is somewhat pleasing to use, and allows the user to remove matches by clicking on the desired row at the number of matches to remove.

A taunt messages appears when the user slips and lets the computer take the advantage and permanently establish the coming victory.

\section{Computer player}
To implement the AI one must compute the so-called nim sum of the board. This is a simple matter of XOR'ing all heaps on the board.

The computer only knows two states of the game:
\begin{description}
\item[Nim sum is $0$:] This is the loosing state and the AI will just remove a single match from the largest heap and hope for the user to blunder.

\item[Nim sum is not $0$:] This is the winning state and to stay in the lead we must find a move that yields a state with a nim sum of $0$. This is done by identifying a heap which decreases when XOR'ed with the nim sum. The optimal move is then to reduce that heap's size by the computed nim sum.
\end{description}

\section{Modular design}
We have designed the program in a way that enforces strict separation of concerns. To do this we made an interface called \texttt{UIState}

\section{Finite-State Automata}
\begin{figure}[H]
\input{fsa.tex}
\caption{Finite-State Automata}
\end{figure}
\end{document}
