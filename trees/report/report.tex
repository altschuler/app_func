%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

\documentclass{article}

\usepackage{fullpage}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage[table]{xcolor}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{parskip}
\usepackage{abstract}
\usepackage{url}
\usepackage{float}
\usepackage{enumitem}
\usepackage{fancybox}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[bottom]{footmisc}
\usepackage{hyperref}
\usepackage{makecell}


% constants
\newcommand{\COURSE}{02257 Applied Functional Programming}
\newcommand{\TITLE}{Project 2}
\newcommand{\DATE}{January 9, 2015}


\input{macros.tex}


\pagestyle{fancy}
\fancyhf{}
\setlength{\parindent}{0pt}
\setlength{\headheight}{15pt}
\setlength{\headsep}{25pt}
\lhead{\COURSE}
\chead{\TITLE}
\rhead{\DATE}
\cfoot{Page \thepage{} of~\pageref{LastPage}}


\title{\TITLE\\ {\large \COURSE}}
\date{\DATE}
\author{
  Markus Færevaag {\tt s123692}\\
  Simon Altschuler {\tt s123563}
}


\begin{document}
\maketitle
\vspace{10cm}
\doublesignature{Markus Færevaag}{Simon Altschuler} \\
\clearpage


\section{Introduction}
In this report we will describe our experience with porting Andrew Kennedy's SML code to F\# and the corresponding optimizations and PostScript document generation.


\section{Status}
All trees generated by our parser for the While language can be rendered using our program. The renderer has a feature which allows rendering the AST of a (valid) While program file directly.

The generated PostScript document renders the AST in a ``pleasing'' manner, where wide labels do not overlap and connections between nodes are nicely curved.

We have implemented two versions of the PostScript generator, one that uses simple \texttt{sprintf} operations and one that utilizes the \texttt{.NET} \texttt{StringBuilder} for performance optimization. We have analyzed the resulting running time of PostScript generation separately and for the full drill of transforming, designing and rendering an AST.

The only issue known to us is the placement of the generated rendering on the page and more importantly the actual size of the page. It is apparently not trivial to set the generated page size in PostScript.

Following is a very brief description of each task and finally the running time analysis.


\section{Porting to F\#}
Porting the SML code to F\# was fairly straight-forward, with most issues being syntactical differences between the languages.


\section{Transforming the AST}
The transformation of the AST to the general \texttt{Tree} data structure was a simple matter of assigning suitable label for each type of node, and recursively parsing their children. There are various ways in which one can choose to represent a node such as \texttt{Apply(name, expressions)}, for instance as a pair, a flattened list containing the name and expressions or having the name in the label of the node. We went for the latter.


\section{Avoiding label overlap}
Prevent wide labels from overlapping can be done in either the design phase or when generating PostScript. We chose to do it in the design phase by passing around the label and extending a node's extent accordingly. This is not an optimal solution because we cannot know the width of the label exactly (further complicated by not using a monospace font). It does however work fairly well for this small use case.


\section{Generating PostScript}
PostScript is a plaintext format which means that it is quite easy to generate. We have written some simple functions such as \texttt{drawLabel} and \texttt{drawCurve} that we use as building blocks in the \texttt{drawTree} function. For the simple \texttt{sprintf} version, all the primitive drawing functions are pure, but the \texttt{StringBuilder} version (\texttt{TreeDrawBuilder.fs}) takes, and modifies, a \texttt{StringBuilder} instance instead of returning a string. It is very imperative in style and ruins the elegance, yet it is much faster (see section \ref{sec:analysis} on analysis), and could most likely be refactored into something easier on the mind and eyes.


\section{Analysis}
\label{sec:analysis}
The complexity of the algorithm is $O(n^2)$ where $n$ is the amount AST nodes, but the amortized cost of the program seems close to linear. It is however obvious that the \texttt{StringBuilder} variant is much faster. Figure \ref{fig:plot} visualizes the running times that we recorded on input sizes ranging from 1 node to 400 nodes.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{../times.pdf}
  \caption{Running times compared to amount of AST nodes}
  \label{fig:plot}
\end{figure}

\section{Running the solution}
To generate a drawing simply run the \texttt{Draw.fsx} file. By default it will rendering the \texttt{program/Factorial1.while} file, but that can be easily changed for another file. A file called \texttt{tree.ps} will be generated with the final rendering.

For what it's worth; the analysis can be run by running the \texttt{Analyze.fsx} file.

\end{document}
