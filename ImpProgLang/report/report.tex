%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

\documentclass{article}

\usepackage{fullpage}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage[table]{xcolor}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{parskip}
\usepackage{abstract}
\usepackage{url}
\usepackage{float}
\usepackage{enumitem}
\usepackage{fancybox}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[bottom]{footmisc}
\usepackage{hyperref}
\usepackage{makecell}


% constants
\newcommand{\COURSE}{02257 Applied Functional Programming}
\newcommand{\TITLE}{Project 1}
\newcommand{\DATE}{January 9, 2015}


\input{macros.tex}


\pagestyle{fancy}
\fancyhf{}
\setlength{\parindent}{0pt}
\setlength{\headheight}{15pt}
\setlength{\headsep}{25pt}
\lhead{\COURSE}
\chead{\TITLE}
\rhead{\DATE}
\cfoot{Page \thepage{} of~\pageref{LastPage}}


\title{\TITLE\\ {\large \COURSE}}
\date{\DATE}
\author{
  Markus Færevaag {\tt s123692}\\
  Simon Altschuler {\tt s123563}
}


\begin{document}
\maketitle
\vspace{10cm}
\doublesignature{Markus Færevaag}{Simon Altschuler} \\
\clearpage


\section{Introduction}
In this report we will describe what language features we have
implemented in the While language, including the required and some
additional. We will end by giving some reflections on the
project.


\section{Features}
We have made all the mandatory language features, such as procedures,
recursive procedures, arrays and conditionals. This means we can run
all the given {\tt .while} programs, which can be tested by running
the {\tt Script.fsx} file, or alternatively, running {\tt make}.

The additional language features we have implemented will be described
in the following subsections.

\subsection{Comments}
We have added comments by simply adding a tokenization rule in the
lexer:
\begin{verbatim}
rule tokenize =
  parse
  | ...
  | "//" [^ '\n']* '\n' { lexbuf.EndPos <- lexbuf.EndPos.NextLine; tokenize lexbuf }
\end{verbatim}

\subsection{Infix ops}
\subsection{Array literal}
Array literals are expressions of the form {\tt [1, 2, 3]} or {\tt ["foo", "bar"]}, and can be thought of as array constants. The semantics of the array declaration are unchanged, so the following will result in a two-dimensional array
\begin{fs}
let int arr[3] : [1, 2, 3] in ...
\end{fs}

A new {\tt Value} constructor has been added:
\begin{fs}
type Value    = | IntVal of int
                ...
                | ArrayVal of List<Value>
\end{fs}

Since arrays are not {\tt SimplVal}s, we must wrap them in {\tt ArrayCnt}s and add them to the store when they are being assigned to a variable.

Empty arrays are not supported because type unification is not implemented, hence we can not type check an array without elements (see \ref{sec:type} about the type system).

\subsection{Declarations-file loading}

To ease loading declarations from a separate file (specifically {\tt ArrayUtils.while}) and to avoid the need to ``hardcode'' an import of the file, we have added a {\tt decls} keyword. It requires a filename, and will load the given file, containing a list of declarations, into the environment and store.

\begin{fs}
let decls "program/ArrayUtil"; in ...
\end{fs}

The above exposes all declarations defined in the {\tt program/ArrayUtil.while} file (relative to the cwd, not the file being intepreted) in the statement block of the {\tt let ... in ...} block.

\subsection{Static type system}
\label{sec:type}


\section{Reflections}
underligt med {\tt let}


\end{document}
